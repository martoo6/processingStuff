/**
 *                     ProScene (version 1.1.96)      
 *    Copyright (c) 2010-2012 by National University of Colombia
 *                 @author Jean Pierre Charalambos      
 *           http://www.disi.unal.edu.co/grupos/remixlab/
 *                           
 * This java package provides classes to ease the creation of interactive 3D
 * scenes in Processing.
 * 
 * This source file is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.
 * 
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 * 
 * A copy of the GNU General Public License is available on the World Wide Web
 * at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by
 * writing to the Free Software Foundation, 51 Franklin Street, Suite 500
 * Boston, MA 02110-1335, USA.
 */

package remixlab.proscene;

import processing.core.*;
import processing.event.*;

import remixlab.proscene.Scene.CameraKeyboardAction;
import remixlab.proscene.Scene.ClickAction;
import remixlab.proscene.Scene.KeyboardAction;
import remixlab.proscene.Scene.MouseAction;

/**
 * This class provides low level processing.event.* based input event handling.
 * <p>
 * In order to handle input events generated by Processing with proscene, this object needs
 * to be registered  at the PApplet (which is done through
 * {@link remixlab.proscene.Scene#enableKeyboardHandling()} and
 * {@link remixlab.proscene.Scene#enableMouseHandling()}). Input events (keyboard and mouse)
 * generated via Processing will then be directed to {@link #keyEvent(KeyEvent)} and to
 * {@link #mouseEvent(MouseEvent)}.  
 */
public class DesktopEvents /** implements MouseWheelListener*/ {
	protected Scene scene;
	protected PApplet parent;
	protected MouseAction camMouseAction;
	protected boolean keyHandled;
  //Z O O M _ O N _ R E G I O N
	public Point fCorner;// also used for SCREEN_ROTATE
	public Point lCorner;
	
	public DesktopEvents(Scene s) {
		scene = s;
		parent = s.parent;
		camMouseAction = MouseAction.NO_MOUSE_ACTION;
		keyHandled = false;
		fCorner = new Point();
		lCorner = new Point();
	}
	
	// 1. KeyEvents
	
	/**
	 * Keyboard event handler.
	 * 
	 * @see remixlab.proscene.Scene#keyboardIsHandled()
	 * @see remixlab.proscene.Scene#enableKeyboardHandling(boolean)
	 */
	public void keyEvent(KeyEvent e) {		
		if( !scene.keyboardIsHandled() )
			return;
		
	  //debug
		/**			
		PApplet.println( "getModifiersExText: " + KeyEvent.getModifiersExText(e.getModifiersEx()) );
		PApplet.println( "getMouseModifiersEx Mask: " + e.getModifiersEx() );
		PApplet.println( "getMouseModifiers Mask: " + e.getModifiers() );
		// */
		
		keyHandled = false;
		switch (e.getAction() ) {
		case KeyEvent.PRESS:
			break;
		case KeyEvent.TYPE:
			keyTyped(e);
			break;
		case KeyEvent.RELEASE:
			keyReleased(e);
			break;
		}
	}
	
	/**
	 * Implementation of the key typed event used to handle character shortcuts.
	 * <p>
	 * The handler queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding there first. If nothing is found,
	 * the handler look for it in the Scene then.
	 * 
	 * @see #keyTypedCameraKeyboardAction(KeyEvent)
	 * @see #keyTypedKeyboardAction(KeyEvent)
	 */
	protected void keyTyped(KeyEvent e) {
		boolean handled = false;		
		if (scene.currentCameraProfile() != null)
			handled = keyTypedCameraKeyboardAction(e);
		if (!handled)
			handled = keyTypedKeyboardAction(e);
		keyHandled = handled;
	}
	
	/**
	 * Implementation of the key released event used to handle complex shortcuts, i.e.,
	 * shortcuts involving a keycode plus a modifier mask.
	 * <p>
	 * The handler looks for a possible binding in the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} first.
	 * If the {@link remixlab.proscene.Scene#currentCameraProfile()} doesn't bind an action,
	 * the handler searches for it in the Scene.
	 * 
	 * @see #keyReleasedCameraKeyboardAction(KeyEvent)
	 * @see #keyReleasedKeyboardAction(KeyEvent)
	 */
	protected void keyReleased(KeyEvent e) {
		if(keyHandled)
			return;
		boolean handled = false;
		if (scene.currentCameraProfile() != null)
			handled = keyReleasedCameraKeyboardAction(e);
		if (!handled)
			keyReleasedKeyboardAction(e);
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the character associated with the key from the KeyEvent
	 * and then queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyTypedCameraKeyboardAction(KeyEvent e) {
		CameraKeyboardAction kba = null;
		kba = scene.currentCameraProfile().shortcut( e.getKey() );
		if (kba == null)
			return false;
		else {
			scene.handleCameraKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the character associated with the key from the KeyEvent
	 * and then queries the Scene to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyTypedKeyboardAction( KeyEvent e) {
		if (!e.isAltDown() /** && !e.isMetaDown() */ && !e.isControlDown()	&& !e.isShiftDown()) {
			Integer path = scene.path(e.getKey());
			if (path != null) {
				scene.camera().playPath(path);
				return true;
			}
		}
		
		KeyboardAction kba = null;
		kba = scene.shortcut(e.getKey());
		if (kba == null)
			return false;
		else {
			scene.handleKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the key combination (keycode +  modifier mask) associated with
	 * the KeyEvent and then queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyReleasedCameraKeyboardAction(KeyEvent e) {
		CameraKeyboardAction kba = null;		
		//kba = scene.currentCameraProfile().shortcut( e.getModifiersEx(), e.getKeyCode() );
		kba = scene.currentCameraProfile().shortcut( e.getModifiers(), e.getKeyCode() );
		if (kba == null)
			return false;
		else {
			scene.handleCameraKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the key combination (keycode +  modifier mask) associated with
	 * the KeyEvent and then queries the Scene to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyReleasedKeyboardAction(KeyEvent e) {
		// 1. Key-frames
		// 1.1. Need to add a key-frame?
		if (((scene.addKeyFrameKeyboardModifier == Event.ALT) && (e.isAltDown()))
	   /** || ((scene.addKeyFrameKeyboardModifier == Scene.Modifier.ALT_GRAPH) && (e.isMetaDown())) */
		 || ((scene.addKeyFrameKeyboardModifier == Event.CTRL) && (e.isControlDown()))
		 || ((scene.addKeyFrameKeyboardModifier == Event.SHIFT) && (e.isShiftDown()))) {
			Integer path = scene.path(e.getKeyCode());
			if (path != null) {
				scene.camera().addKeyFrameToPath(path);
				return true;
			}
		}
  	// 1.2. Need to delete a key-frame?
		if (((scene.deleteKeyFrameKeyboardModifier == Event.ALT) && (e.isAltDown()))
		 /** || ((scene.deleteKeyFrameKeyboardModifier == Scene.Modifier.ALT_GRAPH) && (e.isMetaDown())) */
		 || ((scene.deleteKeyFrameKeyboardModifier == Event.CTRL) && (e.isControlDown()))
		 || ((scene.deleteKeyFrameKeyboardModifier == Event.SHIFT) && (e.isShiftDown()))) {
			Integer path = scene.path(e.getKeyCode());
			if (path != null) {
				scene.camera().deletePath(path);
				return true;
			}
		}		
		// 2. General actions
		KeyboardAction kba = null;
		//kba = scene.shortcut( e.getModifiersEx(), e.getKeyCode() );
		kba = scene.shortcut( e.getModifiers(), e.getKeyCode() );
		if (kba == null)
			return false;
		else {
			scene.handleKeyboardAction(kba);
			return true;
		}
	}
	
	// 2. Mouse Events	
	
	/**
	 * Mouse event handler.
	 * 
	 * @see remixlab.proscene.Scene#mouseIsHandled()
	 * @see remixlab.proscene.Scene#enableMouseHandling(boolean)
	 */
	public void mouseEvent(MouseEvent e) {		
		if ((scene.currentCameraProfile() == null) || (!scene.mouseIsHandled()) )
			return;
		switch (e.getAction() ) {
		case MouseEvent.CLICK:
			mouseClicked(e);
			break;
		case MouseEvent.DRAG:
			mouseDragged(e);
			break;
		case MouseEvent.MOVE:
			mouseMoved(e);
			break;
		case MouseEvent.PRESS:
			mousePressed(e);
			break;
		case MouseEvent.RELEASE:
			mouseReleased(e);
			break;
		}
	}
	
  /**
   * The action generated when the user clicks the mouse is handled by the
   * {@link remixlab.proscene.Scene#mouseGrabber()} (if any). Otherwise
   * looks in the {@link remixlab.proscene.Scene#currentCameraProfile()} to see if there's
   * a binding for this click event, taking into account the button, the modifier mask, and
   * the number of clicks.
   */
	protected void mouseClicked(MouseEvent event) {		
		if (scene.mouseGrabber() != null)
			scene.mouseGrabber().mouseClicked(/**event.getPoint(),*/ event.getButton(), event.getClickCount(), scene.camera());
		else {
			ClickAction ca = scene.currentCameraProfile().clickBinding(event.getModifiers(), event.getButton(), event.getClickCount());
			if (ca != null)
				scene.handleClickAction(ca);
		}		
	}
	
	/**
	 * {@link remixlab.proscene.Scene#setMouseGrabber(MouseGrabbable)} to the MouseGrabber that grabs the
	 * mouse (or to {@code null} if none of them grab it).
	 */
	public void mouseMoved(MouseEvent e) {		
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		scene.setMouseGrabber(null);
		if( scene.hasMouseTracking() )
			for (MouseGrabbable mg : scene.MouseGrabberPool) {
				mg.checkIfGrabsMouse(event.getX(), event.getY(), scene.camera());
				if (mg.grabsMouse())
					scene.setMouseGrabber(mg);
			}
		if ((scene.currentCameraProfile().mode() == CameraProfile.Mode.FIRST_PERSON) &&
				/**( (e.getButton() != PApplet.LEFT) && (e.getButton() != PApplet.CENTER) && (e.getButton() != PApplet.RIGHT) ) &&*/ 
				(scene.cursorIsHiddenOnFirstPerson()) ) {
			scene.camera().frame().startAction(Scene.MouseAction.LOOK_AROUND, scene.drawIsConstrained());
			scene.camera().frame().mouseDragged(event, scene.camera());
		}
	}
	
	/**
	 * The action generated when the user clicks and drags the mouse is handled by the
	 * {@link remixlab.proscene.Scene#mouseGrabber()} (if any), or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}
	 * (if @link remixlab.proscene.Scene#interactiveFrameIsDrawn()), or the
	 * {@link remixlab.proscene.Scene#camera()} (checks are performed in that order).
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #mouseDragged(MouseEvent)
	 * @see #mouseReleased(MouseEvent) 
	 */
	public void mousePressed(MouseEvent e) {		
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.mouseGrabber() != null) {
			if (scene.mouseGrabberIsAnIFrame) { //covers also the case when mouseGrabberIsADrivableFrame
				InteractiveFrame iFrame = (InteractiveFrame) scene.mouseGrabber();
				iFrame.startAction(scene.currentCameraProfile().frameMouseAction(e), scene.drawIsConstrained());
				iFrame.mousePressed(new Point(event.getX(), event.getY()), scene.camera());
			} else
				scene.mouseGrabber().mousePressed(new Point(event.getX(), event.getY()), scene.camera());
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			scene.interactiveFrame().startAction(scene.currentCameraProfile().frameMouseAction(e), scene.drawIsConstrained());
			scene.interactiveFrame().mousePressed(new Point(event.getX(), event.getY()), scene.camera());
			return;
		}
		camMouseAction = scene.currentCameraProfile().cameraMouseAction(e);
		if (camMouseAction == MouseAction.ZOOM_ON_REGION) {
			fCorner.set(event.getX(), event.getY());
			lCorner.set(event.getX(), event.getY());
		}
		if (camMouseAction == MouseAction.SCREEN_ROTATE)
			fCorner.set(event.getX(), event.getY());
		scene.camera().frame().startAction(camMouseAction, scene.drawIsConstrained());
		scene.camera().frame().mousePressed(new Point(event.getX(), event.getY()), scene.camera());
	}
	
	/**
	 * The mouse dragged event is sent to the {@link remixlab.proscene.Scene#mouseGrabber()}
	 * or the {@link remixlab.proscene.Scene#interactiveFrame()}, or to the
	 * {@link remixlab.proscene.Scene#camera()}, according to the action started at
	 * {@link #mousePressed(MouseEvent)}.
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #mousePressed(MouseEvent)
	 * @see #mouseReleased(MouseEvent)
	 */
	public void mouseDragged(MouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.mouseGrabber() != null) {
			scene.mouseGrabber().checkIfGrabsMouse(event.getX(), event.getY(), scene.camera());
			if (scene.mouseGrabber().grabsMouse())
				if (scene.mouseGrabberIsAnIFrame) //covers also the case when mouseGrabberIsADrivableFrame
					((InteractiveFrame) scene.mouseGrabber()).mouseDragged(new Point(event.getX(), event.getY()), scene.camera());	
				else
					scene.mouseGrabber().mouseDragged(new Point(event.getX(), event.getY()), scene.camera());
			else
				scene.setMouseGrabber(null);
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
		  scene.interactiveFrame().mouseDragged(new Point(event.getX(), event.getY()), scene.camera());
			return;
		}
		if (camMouseAction == MouseAction.ZOOM_ON_REGION)
			lCorner.set(event.getX(), event.getY());
		else {
			if (camMouseAction == MouseAction.SCREEN_ROTATE)
				fCorner.set(event.getX(), event.getY());
			scene.camera().frame().mouseDragged(new Point(event.getX(), event.getY()), scene.camera());
		}
	}
	
	/**
	 * The mouse released event (which ends a mouse action) is sent to the
	 * {@link remixlab.proscene.Scene#mouseGrabber()} or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}, or to the
	 * {@link remixlab.proscene.Scene#camera()}, according to the action started at
	 * {@link #mousePressed(MouseEvent)}.
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #mousePressed(MouseEvent)
	 * @see #mouseDragged(MouseEvent)
	 */
	public void mouseReleased(MouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.mouseGrabber() != null) {
			if (scene.mouseGrabberIsAnIFrame) //covers also the case when mouseGrabberIsADrivableFrame
				((InteractiveFrame) scene.mouseGrabber()).mouseReleased(new Point(event.getX(), event.getY()), scene.camera());
			else
				scene.mouseGrabber().mouseReleased(new Point(event.getX(), event.getY()), scene.camera());
			scene.mouseGrabber().checkIfGrabsMouse(event.getX(), event.getY(), scene.camera());
			if (!(scene.mouseGrabber().grabsMouse()))
				scene.setMouseGrabber(null);
			// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			scene.interactiveFrame().mouseReleased(new Point(event.getX(), event.getY()), scene.camera());
			// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
			return;
		}

		if ((camMouseAction == MouseAction.ZOOM_ON_REGION)
				|| (camMouseAction == MouseAction.SCREEN_ROTATE)
				|| (camMouseAction == MouseAction.SCREEN_TRANSLATE))
			lCorner.set(event.getX(), event.getY());
		scene.camera().frame().mouseReleased(new Point(event.getX(), event.getY()), scene.camera());
		camMouseAction = MouseAction.NO_MOUSE_ACTION;
		// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
	}
	
	// 2.b Wheel	
	
	//TODO wheel
	
	/**
	 * The action generated when the user start rotating the mouse wheel is handled by the
	 * {@link remixlab.proscene.Scene#mouseGrabber()} (if any), or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}
	 * (if @link remixlab.proscene.Scene#interactiveFrameIsDrawn()), or the
	 * {@link remixlab.proscene.Scene#camera()} (checks are performed in that order).
	 * <p>
	 * Mouse wheel rotation is interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse wheel bindings.
	 * 
	 * @see #mousePressed(MouseEvent)
	 */
	
	/**
	public void mouseWheelMoved(MouseWheelEvent event) {
		if(!scene.mouseIsHandled())
			return;
		if (scene.mouseGrabber() != null) {
			if (scene.mouseGrabberIsAnIFrame) { //covers also the case when mouseGrabberIsADrivableFrame
				InteractiveFrame iFrame = (InteractiveFrame) scene.mouseGrabber();
				iFrame.startAction(scene.currentCameraProfile().frameWheelMouseAction(event), scene.drawIsConstrained());
				iFrame.mouseWheelMoved(event.getWheelRotation(), scene.camera());				
			} else
				scene.mouseGrabber().mouseWheelMoved(event.getWheelRotation(), scene.camera());
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			scene.interactiveFrame().startAction(scene.currentCameraProfile().frameWheelMouseAction(event), scene.drawIsConstrained());
			scene.interactiveFrame().mouseWheelMoved(event.getWheelRotation(), scene.camera());
			return;
		}
		scene.camera().frame().startAction(scene.currentCameraProfile().cameraWheelMouseAction(event), scene.drawIsConstrained());
		scene.camera().frame().mouseWheelMoved(event.getWheelRotation(), scene.camera());
	}
	*/
	
	// 3. Utility package dependent functions: java.awt wrappers that should be replaced
	//    by each platform where proscene is going to be implemented.

	/**
	 * Function that maps characters to virtual keys defined according to
	 * {@code java.awt.event.KeyEvent}.
	 */
	public static int getVKey(char key) {
	  if(key == '0') return 48;
	  if(key == '1') return 49;
	  if(key == '2') return 50;
	  if(key == '3') return 51;
	  if(key == '4') return 52;
	  if(key == '5') return 53;
	  if(key == '6') return 54;
	  if(key == '7') return 55;
	  if(key == '8') return 56;
	  if(key == '9') return 57;		
	  if((key == 'a')||(key == 'A')) return 65;
	  if((key == 'b')||(key == 'B')) return 66;
	  if((key == 'c')||(key == 'C')) return 67;
	  if((key == 'd')||(key == 'D')) return 68;
	  if((key == 'e')||(key == 'E')) return 69;
	  if((key == 'f')||(key == 'F')) return 70;
	  if((key == 'g')||(key == 'G')) return 71;
	  if((key == 'h')||(key == 'H')) return 72;
	  if((key == 'i')||(key == 'I')) return 73;
	  if((key == 'j')||(key == 'J')) return 74;
	  if((key == 'k')||(key == 'K')) return 75;
	  if((key == 'l')||(key == 'L')) return 76;
	  if((key == 'm')||(key == 'M')) return 77;
	  if((key == 'n')||(key == 'N')) return 78;
	  if((key == 'o')||(key == 'O')) return 79;
	  if((key == 'p')||(key == 'P')) return 80;
	  if((key == 'q')||(key == 'Q')) return 81;
	  if((key == 'r')||(key == 'R')) return 82;
	  if((key == 's')||(key == 'S')) return 83;
	  if((key == 't')||(key == 'T')) return 84;
	  if((key == 'u')||(key == 'U')) return 85;
	  if((key == 'v')||(key == 'V')) return 86;
	  if((key == 'w')||(key == 'W')) return 87;
	  if((key == 'x')||(key == 'X')) return 88;
	  if((key == 'y')||(key == 'Y')) return 89;
	  if((key == 'z')||(key == 'Z')) return 90;
	  return -1;
	}
	
	/**
	 * Wrapper function that simply returns what
	 * {@code java.awt.event.KeyEvent.getKeyText(key)} would return.
	 */
	public static String getKeyText(int key) {
    String result;
    switch (key) {
        case 48: result = "0"; break;
        case 49: result = "1"; break;
        case 50: result = "2"; break;
        case 51: result = "3"; break;
        case 52: result = "4"; break;
        case 53: result = "5"; break;
        case 54: result = "6"; break;
        case 55: result = "7"; break;
        case 56: result = "8"; break;
        case 57: result = "9"; break;
        case 65: result = "a"; break;
        case 66: result = "b"; break;
        case 67: result = "c"; break;
        case 68: result = "d"; break;
        case 69: result = "e"; break;
        case 70: result = "f"; break;
        case 71: result = "g"; break;
        case 72: result = "h"; break;
        case 73: result = "i"; break;
        case 74: result = "j"; break;
        case 75: result = "k"; break;
        case 76: result = "l"; break;
        case 77: result = "m"; break;
        case 78: result = "n"; break;
        case 79: result = "o"; break;
        case 80: result = "p"; break;
        case 81: result = "q"; break;
        case 82: result = "r"; break;
        case 83: result = "s"; break;
        case 84: result = "t"; break;
        case 85: result = "u"; break;
        case 86: result = "v"; break;
        case 87: result = "w"; break;
        case 88: result = "x"; break;
        case 89: result = "y"; break;
        case 90: result = "z"; break;
        case PApplet.LEFT: result = "LEFT"; break;
        case PApplet.RIGHT: result = "RIGHT"; break;
        case PApplet.UP: result = "UP"; break;
        case PApplet.DOWN: result = "DOWN"; break;
        default: result = "Unrecognized key";
                 break;                 
    }
    return result;
	}
	
	public static String getModifiersText(int mask) {
		String r = new String();
		if((Event.ALT & mask) == Event.ALT) r += "ALT";						
		if((Event.SHIFT & mask) == Event.SHIFT) r += (r.length() > 0) ? "+SHIFT" : "SHIFT";
		if((Event.CTRL & mask) == Event.CTRL) r += (r.length() > 0) ? "+CTRL" : "CTRL";
		if((Event.META & mask) == Event.META) r += (r.length() > 0) ? "+META" : "META";
		return r;
	}	
}
